# 下一个排列

## 题目

整数数组的一个 **排列**  就是将其所有成员以序列或线性顺序排列。

* 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]  

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

* 例如，**arr = [1,2,3]** 的下一个排列是 **[1,3,2]** 。
* 类似地，**arr = [2,3,1]** 的下一个排列是 **[3,1,2]** 。
* 而 **arr = [3,2,1]** 的下一个排列是 **[1,2,3]** ，因为 **[3,2,1]** 不存在一个字典序更大的排列。

给你一个整数数组 **nums** ，找出 **nums** 的下一个排列。

必须 **原地** 修改，只允许使用额外常数空间。

通俗解释:

**给定若干个数字将其组合为一个整数.如何将这些数字重新排列,以得到下一个更大的整数.如 123 下一个更大的数为 132.如果没有更大的整数,则输出最小的整数**

示例:

```text
输入：nums = [3,2,1]
输出：[1,2,3]
```

---

## code

```go
func nextPermutation(nums []int) {
 // 翻译下 给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列
 // 等同于 给定若干个数字将其组合为一个整数.如何将这些数字重新排列,以得到下一个更大的整数.如 123 下一个更大的数为 132.如果没有更大的整数,则输出最小的整数
 l := len(nums)
 if l < 2 {
  return
 }
 // 从后往前开始匹配,设置两个指针i,j
 // 找到第一个 nums[i] < nums[j] 处
 i, j, k := l-2, l-1, l-1
 for i >= 0 && nums[i] >= nums[j] {
  i--
  j--
 }

 // 在在[j,l)中寻找 nums[i] < nums[k] 满足的指针k的位置
 // 调换 i,k 位置
 // i<0标识数组元素是降序的,只要变为升序即可
 if i >= 0 {
  for k >= j && nums[i] >= nums[k] {
   k--
  }
  if nums[i] < nums[k] {
   nums[i], nums[k] = nums[k], nums[i]
  }
 }

 // [j,l)转换为升序
 for i, j := j, l-1; i < j; i, j = i+1, j-1 {
  nums[i], nums[j] = nums[j], nums[i]
 }
}
```

# 下一个排列

## 题目

整数数组的一个 **排列**  就是将其所有成员以序列或线性顺序排列。

* 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]  

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

* 例如，**arr = [1,2,3]** 的下一个排列是 **[1,3,2]** 。
* 类似地，**arr = [2,3,1]** 的下一个排列是 **[3,1,2]** 。
* 而 **arr = [3,2,1]** 的下一个排列是 **[1,2,3]** ，因为 **[3,2,1]** 不存在一个字典序更大的排列。

给你一个整数数组 **nums** ，找出 **nums** 的下一个排列。

必须 **原地** 修改，只允许使用额外常数空间。

通俗解释:

**给定若干个数字将其组合为一个整数.如何将这些数字重新排列,以得到下一个更大的整数.如 123 下一个更大的数为 132.如果没有更大的整数,则输出最小的整数**

示例:

```text
输入：nums = [3,2,1]
输出：[1,2,3]
```

---

## code

```go

// 翻译下 给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列
// 等同于 给定若干个数字将其组合为一个整数.如何将这些数字重新排列,以得到下一个更大的整数.
// 以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列
// Next permutation
func nextPermutation(nums []int) {
	l := len(nums)
	if l < 2 {
		return
	}
	// 构建从后向前的快慢指针
	s, q, index := l-1, l-2, l-1
	// 向前遍历,寻找第一个相邻可交换的位置,跳出循环时[s,l)必然降序
	for q >= 0 && nums[q] >= nums[s] {
		s--
		q--
	}

	// 表示整个序列非升序,尝试在[s,l)之间找到一个比nums[q]小的数
	// 经过下面操作,此时[s,l)任然是降序
	if q >= 0 {
		for index >= s && nums[q] >= nums[index] {
			index--
		}
		if nums[q] < nums[index] {
			nums[q], nums[index] = nums[index], nums[q]
		}
	}

	// 对[s,l)进行升序排列
	for i, j := s, l-1; i < j; i, j = i+1, j-1 {
		nums[i], nums[j] = nums[j], nums[i]
	}
}
```

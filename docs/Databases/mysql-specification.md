---
group: Mysql相关
order: 0
---

# MySQL 数据库设计规范

## 目录

* [1. 规范背景与目的](#1-规范背景与目的)
* [2. 设计规范](#2-设计规范)
  * [2.1 数据库设计](#21-数据库设计)
    * [2.1.1 一般命名规则](#211-一般命名规则)
    * [2.1.2 库](#212-库)
    * [2.1.3 表](#213-表)
    * [2.1.4 字段](#214-字段)
    * [2.1.5 字段数据类型优化](#215-字段数据类型优化)
    * [2.1.6 索引设计](#216-索引设计)
    * [2.1.7 分库分表、分区表](#217-分库分表、分区表)
    * [2.1.8 字符集](#218-字符集)
    * [2.1.9 程序层 DAO 设计建议](#219-程序层-DAO-设计建议)
    * [2.1.10 一个规范的建表语句示例](#2110-一个规范的建表语句示例)
  * [2.2 SQL 编写](#22-SQL-编写)
    * [2.2.1 DML 语句](#221-DML-语句)
    * [2.2.2 多表连接](#222-多表连接)
    * [2.2.3 事务](#223-事务)
    * [2.2.4 排序和分组](#224-排序和分组)

# 1. 规范背景与目的

MySQL 数据库与 Oracle、 SQL Server 等数据库相比, 有其内核上的优势与劣势. 在使用 MySQL 数据库的时候需要遵循一定规范, 扬长避短. 

本规范旨在帮助或指导技术人员做出适合线上业务的数据库设计. 

在数据库变更和处理流程、数据库表设计、SQL 编写等方面予以规范, 从而为公司业务系统稳定、健康地运行提供保障. 

# 2. 设计规范

## 2.1 数据库设计

以下所有规范会按照【高危】、【强制】、【建议】三个级别进行标注, 遵守优先级从高到低. 

### 2.1.1 一般命名规则

* 【强制】使用小写, 避免因大小写敏感而导致的错误. 
* 【强制】没有空格, 使用下划线代替. 
* 【强制】名称中没有数字, 只有英文字母. 
* 【强制】有效的可理解的名称. 
* 【建议】名称应该是自我解释的. 
* 【建议】名称不应超过 32 个字符. 
* 【建议】避免使用前缀. 

### 2.1.2 库

* 【强制】遵守以上全部一般命名规则. 
* 【建议】使用单数. 
* 【建议】库的名称格式：业务系统名称_子系统名. 
* 【建议】一般分库名称命名格式是`库通配名_编号`, 编号从 0 开始递增
  * 比如 `northwind_001`, 以时间进行分库的名称格式是`库通配名_时间`. 
* 【建议】创建数据库时必须显式指定字符集. 创建数据库 SQL 举例：
 
    ```sql
    create database db_name default character set utf8;
    ```

### 2.1.3 表

* 【强制】遵守以上全部一般命名规则. 
* 【强制】使用单数. 
* 【强制】相关模块的表名与表名之间尽量体现 join 的关系
  * 如 `user` 表和 `user_login` 表. 
* 【强制】建表必须有 comment. 
* 【强制】核心表（如用户表, 金钱相关的表）必须有行数据的创建时间字段 `create_time` 和最后更新时间字段 `update_time`, 便于排查问题. 
* 【强制】关于主键：
  * 命名为 `id`, 类型为 int 或 bigint, 且为 `auto_increment`；
  * 标识表里每一行主体的字段不要设为主键, 建议设为其它字段如 `user_id`, `order_id`等, 并建立 `unique key` 索引. 
  * 主体的字段如果设为主键且主键值为随机插入, 则会导致 InnoDB 内部 page 分裂和大量随机 I/O, 性能下降. 
* 【建议】创建表时必须显式指定表存储引擎类型, 如无特殊需求, 一律为 InnoDB. 
  * 因为 InnoDB 表支持事务、行锁、宕机恢复、MVCC 等关系型数据库重要特性, 为业界使用最多的 MySQL 存储引擎
* 【建议】表中所有字段必须都是 `NOT NULL` 属性, 业务可以根据需要定义 `DEFAULT` 值. 
  * 因为使用 `NULL` 值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题. 
* 【建议】建议对表里的 `blob`、`text` 等大字段, 垂直拆分到其它表里, 仅在需要读这些对象的时候才去 select. 
* 【建议】反范式设计：把经常需要 join 查询的字段, 在其它表里冗余一份. 如 `username` 属性在 `user_account`, `user_login_log` 等表里冗余一份, 减少 join 查询. 
* 【强制】对于超过 100W 行的大表进行 `alter table`, 必须经过相关开发人员集体审核, 并在业务低峰期执行. 因为 `alter table` 会产生表锁, 期间阻塞对于该表的所有写入, 对于业务可能会产生极大影响. 

### 2.1.4 字段

* 【强制】遵守以上全部一般命名规则. 
* 【强制】避免使用保留字作为字段名称：`order`, `date`, `name` 是数据库的保留字, 避免使用它. 可以为这些名称添加前缀使其易于理解, 如 `user_name`, `signup_date` 等. 
* 【强制】避免使用与表名相同的字段名, 这会在编写查询时造成混淆. 
* 【强制】避免使用缩写或基于首字母缩写词的名称. 
* 【建议】外键列必须具有表名及其主键, 例如：`blog_id` 表示来自表博客的外键 id. 
* 【建议】尽可能选择短的或一两个单词. 

### 2.1.5 字段数据类型优化

* 【建议】表中的自增列（`auto_increment` 属性）, 推荐使用 `bigint` 类型. 因为无符号 `int` 存储范围为 `0~4,294,967,295`（不到 43 亿）, 溢出后会导致报错. 
* 【建议】业务中选择性很少的状态 `status`、类型 `type` 等字段推荐使用 `tinytint` 或者 `smallint` 类型节省存储空间. 
* 【建议】不推荐使用 `enum`, `set`.  因为它们浪费空间, 且枚举值写死了, 变更不方便. 推荐使用 `tinyint` 或 `smallint`. 
* 【建议】不推荐使用 `blob`, `text` 等类型. 
  * 它们都比较浪费硬盘和内存空间. 在加载表数据时, 会读取大字段到内存里从而浪费内存空间, 影响系统性能. 
  * InnoDB 中当一行记录超过 8098 字节时, 会将该记录中选取最长的一个字段将其 768 字节放在原始 page 里, 该字段余下内容放在 `overflow-page` 里. 不幸的是在 `compact` 行格式下, 原始 `page` 和 `overflow-page` 都会加载. 
* 【建议】存储金钱的字段, 建议用 `int` 以分为单位存储, 最大数值约 4290 万, 程序端乘以 100 和除以 100 进行存取. 
  * 因为 `int` 占用 4 字节, 而 `double` 占用 8 字节, 空间浪费. 
* 【建议】文本数据尽量用 `varchar` 存储. 因为 `varchar` 是变长存储, 比 `char` 更省空间. 
  * MySQL server 层规定一行所有文本最多存 65535 字节, 因此在 utf8 字符集下最多存 21844 个字符, 超过会自动转换为 `mediumtext` 字段. 
  * `text` 在 utf8 字符集下最多存 21844 个字符
  * `mediumtext` 最多存 2^24/3 个字符
  * `longtext` 最多存 2^32 个字符.
  * 一般建议用 `varchar` 类型, 字符数不要超过 2700. 

* 详细存储大小参考下图：

    | 类型（同义词）                                | 存储长度(BYTES)   | 最小值(SIGNED/UNSIGNED)            | 最大值(SIGNED/UNSIGNED)|
    |---------------------------------------------|--------|---------------------|------------------------|
    | *整形数字*                                   |        |                     |                        |
    | TINYINT                                     | 1      | -128/0             | 127/255                 |
    | SMALLINT                                    | 2      | -32,768/0           | 32767/65,535           |
    | MEDIUMINT                                   | 3      | -8,388,608/0         | 8388607/16,777,215/      |
    | INT(INTEGER)                                | 4      | -2,14,7483,648/0     | 2147483647/4,294,967,295/ |
    | BIGINT                                      | 8      | -2^63/0 |    2^63-1/2^64-1 |
    | *小数支持*                                   |        |                     |                        |
    | FLOAT[(M[,D])]                              | 4 or 8 | -                   |                        |
    | DOUBLE[(M[,D])]<br>(REAL, DOUBLE PRECISION) | 8      | -                   |                        |
    | *时间类型*                                   |        |                     |                        |
    | DATETIME                                    | 8      | 1001-01-01 00:00:00 | 9999-12-31 23:59:59    |
    | DATE                                        | 3      | 1001-01-01          | 9999-12-31             |
    | TIME                                        | 3      | 00:00:00            | 23:59:59               |
    | YEAR                                        | 1      | 1001                | 9999                   |
    | TIMESTAMP                                   | 4      | 1970-01-01 00:00:00 |                        |

### 2.1.6 索引设计

* 【强制】InnoDB 表必须主键为 `id int/bigint auto_increment`, 且主键值禁止被更新. 
* 【强制】InnoDB 和 MyISAM 存储引擎表, 索引类型必须为 `BTREE`；MEMORY 表可以根据需要选择 `HASH` 或者 `BTREE` 类型索引. 
* 【强制】单个索引中每个索引记录的长度不能超过 64KB. 
* 【建议】单个表上的索引个数不能超过 7 个. 
* 【建议】在建立索引时, 多考虑建立联合索引, 并把区分度最高的字段放在最前面. 如列 `user_id` 的区分度可由 `select count(distinct user_id)` 计算出来. 
* 【建议】在多表 join 的 SQL 里, 保证被驱动表的连接列上有索引, 这样 join 执行效率最高. 
* 【建议】建表或加索引时, 保证表里互相不存在冗余索引. 对于 MySQL 来说, 如果表里已经存在 `key(a, b)`, 则 `key(a)` 为冗余索引, 需要删除. 
* 【建议】如果选择性超过 20%, 那么全表扫描比使用索引性能更优, 即没有设置索引的必要. 

### 2.1.7 分库分表、分区表

* 【强制】分区表的分区字段（`partition-key`）必须有索引, 或者是组合索引的首列. 
* 【强制】单个分区表中的分区（包括子分区）个数不能超过 1024. 
* 【强制】访问分区表的 SQL 必须包含分区键. 
* 【建议】单个分区文件不超过 2G, 总大小不超过 50G. 建议总分区数不超过 20 个. 
* 【强制】对于分区表执行 `alter table` 操作, 必须在业务低峰期执行. 
* 【强制】采用分库策略的, 库的数量不能超过 1024. 
* 【强制】采用分表策略的, 表的数量不能超过 4096. 
* 【建议】单个分表不超过 500W 行, ibd 文件大小不超过 2G, 这样才能让数据分布式变得性能更佳. 
* 【建议】水平分表尽量用取模方式, 日志、报表类数据建议采用日期进行分表. 

### 2.1.8 字符集

* 【强制】数据库本身库、表、列所有字符集必须保持一致, 为 `utf8` 或 `utf8mb4`. 
* 【强制】程序字符集或者环境变量中的字符集, 与数据库、表的字符集必须一致, 统一为 `utf8`. 

### 2.1.9 程序层 DAO 设计建议

* 【建议】封装数据库连接

  * 使用数据库连接池来管理数据库连接, 确保在应用程序运行期间保持连接的可用性. 
  * 在 DAO 层中封装数据库连接的创建和释放, 以确保代码的干净性. 

* 【建议】在业务逻辑层决定何时开始和提交事务, 而 DAO 则负责实际的数据库事务处理

* 【建议】错误处理
  * 避免在 DAO 中直接 panic, 而应该返回错误供上层处理. 

* 【建议】模型设计
  * 定义数据库模型, 将数据库表映射为 Go 结构体
  * 可以使用 ORM（Object-Relational Mapping）库, 如 Gorm, 也可以手动实现结构体和数据库表之间的映射

* 【建议】参数化查询
  * 避免直接拼接 SQL 查询字符串, 而是使用参数化占位符的形式查询来防止 SQL 注入攻击. 

* 【建议】多个并发业务逻辑访问同一块数据（InnoDB 表）时, 会在数据库端产生行锁甚至表锁导致并发下降, 因此建议更新类 SQL 尽量基于主键去更新. 

* 【建议】业务逻辑之间加锁顺序尽量保持一致, 否则会导致死锁

* 【建议】对于单表读写比大于 10:1 的数据行或单个列, 可以将热点数据放在缓存里（如 Memcached 或 Redis）, 加快访问速度, 降低 MySQL 压力

### 2.1.10 一个规范的建表语句示例

* 一个较为规范的建表语句为：

    ```sql
    create table user 
    ( 
        `id`            bigint(11) not null auto_increment, 
        `user_id`       bigint(11) not null comment '用户 ID', 
        `user_name`      varchar(45) not null comment '登录名', 
        `email`         varchar(30) not null comment '邮箱', 
        `nick_name`      varchar(45) not null comment '昵称', 
        `avatar`        int(11) not null comment '头像', 
        `birthday`      date not null comment '生日', 
        `gender`        tinyint(4) default '0' comment '性别', 
        `intro`         varchar(150) default null comment '简介', 
        `resume_url`    varchar(300) not null comment '简历存放地址', 
        `register_ip`   int not null comment '用户注册时的源 IP', 
        `review_status` tinyint not null comment '审核状态, 1-通过, 2-审核中, 3-未通过, 4-尚未提交审核', 
        `create_time`   timestamp not null comment '记录创建的时间', 
        `update_time`   timestamp not null comment '资料修改的时间', 
        
        primary key (`id`), 
        unique key `idx_user_id` (`user_id`), 
        key `idx_username`(`username`), 
        key `idx_create_time`(`create_time`, `review_status`) 
    ) 
    engine = InnoDB comment = '用户基本信息'; 
    ```

## 2.2 SQL 编写

### 2.2.1 DML 语句

* 【建议】insert 语句指定具体字段名称, 不要写成 `insert into t1 values(…)`, 道理同上. 
* 【建议】select 语句不要使用 `union`, 推荐使用 `union all`, 并且 `union` 子句个数限制在 5 个以内. 因为 `union all` 不需要去重, 节省数据库资源, 提高性能. 
* 【建议】事务涉及的表必须全部是 InnoDB 表. 否则一旦失败不会全部回滚, 且易造成主从库同步终端. 
* 【建议】写入和事务发往主库, 只读 SQL 发往从库. 
* 【建议】除静态表或小表（100 行以内）, dml 语句必须有 where 条件, 且使用索引查找. 
* 【建议】where 条件里等号左右字段类型必须一致, 否则无法利用索引. 
* 【建议】`select|update|delete|replace` 要有 where 子句, 且 where 子句的条件必需使用索引查找. 
* 【建议】生产数据库中强烈不推荐大表上发生全表扫描, 但对于 100 行以下的静态表可以全表扫描. 查询数据量不要超过表行数的 25%, 否则不会利用索引. 
* 【建议】select 语句必须指定具体字段名称, 禁止写成 `*`. 因为 `select *` 会将不该读的数据也从 MySQL 里读出来. 
* 【建议】where 子句中禁止只使用全模糊的 like 条件进行查找, 必须有其它等值或范围查询条件, 否则无法利用索引. 
* 【建议】索引列不要使用函数或表达式, 否则无法利用索引. 如 `where length(name) = 'admin'` 或 `where user_id + 2 = 10023`. 
* 【建议】分页查询, 当 `limit` 起点较高时, 可先用过滤条件进行过滤. 如 `select a, b, c from t1 limit 10000, 20;` 优化为: `select a, b, c from t1 where id > 10000 limit 20;`. 

### 2.2.2 多表连接

* 【建议】禁止跨 DB 的 join 语句. 因为这样可以减少模块间耦合, 为数据库拆分奠定坚实基础. 
* 【建议】禁止在业务的更新类 SQL 语句中使用 join, 比如 `update t1 join t2 …`. 
* 【建议】不建议使用子查询, 建议将子查询 SQL 拆开结合程序多次查询, 或使用 join 来代替子查询. 
* 【建议】线上环境, 多表 join 不要超过 3 个表. 
* 【建议】多表连接查询推荐使用别名, 且 select 列表中要用别名引用字段, 数据库.表格式, 如 `select a from db1.table1 alias1 where …`. 
* 【建议】在多表 join 中, 尽量选取结果集较小的表作为驱动表, 来 join 其它表. 

### 2.2.3 事务

* 【建议】事务中 `insert|update|delete|replace` 语句操作的行数控制在 2000 以内, 以及 where 子句中 in 列表的传参个数控制在 500 以内. 
* 【建议】批量操作数据时, 需要控制事务处理间隔时间, 进行必要的 sleep, 一般建议值 5-10 秒. 
* 【建议】对于有 `auto_increment` 属性字段的表的插入操作, 并发需要控制在 200 以内. 
* 【建议】程序设计必须考虑“数据库事务隔离级别”带来的影响, 包括脏读、不可重复读和幻读. 线上建议事务隔离级别为 `repeatable-read`. 
* 【建议】事务里包含 SQL 不超过 5 个（支付业务除外）. 因为过长的事务会导致锁数据较久, MySQL 内部缓存、连接消耗过多等雪崩问题. 
* 【建议】事务里更新语句尽量基于主键或 `unique key`, 如 `update … where id = XX;`, 否则会产生间隙锁, 内部扩大锁定范围, 导致系统性能下降, 产生死锁. 
* 【建议】尽量把一些典型外部调用移出事务, 如调用 Web Service, 访问文件存储等, 从而避免事务过长. 
* 【建议】对于 MySQL 主从延迟严格敏感的 select 语句, 请开启事务强制访问主库. 

### 2.2.4 排序和分组

* 【建议】`order by`、`group by`、`distinct` 这些 SQL 尽量利用索引直接检索出排序好的数据. 如 `where a = 1 order by` 可以利用 `key(a, b)`. 
* 【建议】减少使用 `order by`, 和业务沟通能不排序就不排序, 或将排序放到程序端去做. `order by`、`group by`、`distinct` 这些语句较为耗费 CPU, 数据库的 CPU 资源是极其宝贵的. 
* 【建议】包含了 `order by`、`group by`、`distinct` 这些查询的语句, where 条件过滤出来的结果集请保持在 1000 行以内, 否则 SQL 会很慢. 